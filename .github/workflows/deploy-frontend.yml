name: Deploy Frontend

on:
  push:
    branches: [main]
    paths:
      - 'frontend/**'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}      
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Connect to AKS
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_NAME }} \
            --overwrite-existing
      
      - name: Get Backend Service URL
        id: get-backend-url
        run: |
          echo "Checking backend service status..."
          kubectl get svc backend-api-service -n tsp-app
          
          # Wait for LoadBalancer to get an external IP (max 2 minutes)
          echo "Waiting for LoadBalancer to get external IP..."
          for i in {1..24}; do
            BACKEND_IP=$(kubectl get svc backend-api-service -n tsp-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
            if [ -n "$BACKEND_IP" ]; then
              # Check if it's a public IP (not in private ranges)
              if [[ ! "$BACKEND_IP" =~ ^10\. ]] && [[ ! "$BACKEND_IP" =~ ^172\.(1[6-9]|2[0-9]|3[01])\. ]] && [[ ! "$BACKEND_IP" =~ ^192\.168\. ]]; then
                echo "‚úì Found public IP: $BACKEND_IP"
                BACKEND_URL="http://${BACKEND_IP}:80"
                break
              else
                echo "‚ö† Found private IP: $BACKEND_IP (waiting for public IP...)"
              fi
            fi
            
            if [ $i -lt 24 ]; then
              sleep 5
            fi
          done
          
          # If still no public IP, check service annotations
          if [ -z "$BACKEND_URL" ] || [[ "$BACKEND_IP" =~ ^172\. ]] || [[ "$BACKEND_IP" =~ ^10\. ]] || [[ "$BACKEND_IP" =~ ^192\.168\. ]]; then
            echo "‚ö†Ô∏è Warning: Service appears to be internal or no public IP assigned"
            echo "Checking service annotations..."
            kubectl get svc backend-api-service -n tsp-app -o yaml | grep -i internal || echo "No internal annotation found"
            
            # Try to get the IP anyway (might work with VNet integration)
            if [ -n "$BACKEND_IP" ]; then
              BACKEND_URL="http://${BACKEND_IP}:80"
              echo "‚ö†Ô∏è Using IP: $BACKEND_IP (may require VNet integration)"
            else
              echo "‚ùå Error: No backend IP found. Please ensure the service is configured as public LoadBalancer."
              exit 1
            fi
          fi
          
          echo "Backend URL: $BACKEND_URL"
          echo "REACT_APP_API_URL=$BACKEND_URL" >> $GITHUB_ENV
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
          
          # Test connectivity
          echo "Testing backend connectivity..."
          curl -f "${BACKEND_URL}/health" && echo "‚úì Backend is reachable" || echo "‚ö†Ô∏è Backend health check failed (may still work)"
          
      - name: Build
        working-directory: ./frontend
        env:
          REACT_APP_API_URL: ${{ env.REACT_APP_API_URL || 'http://localhost:3001' }}
        run: |
          echo "Building with API URL: $REACT_APP_API_URL"
          npm install
          npm run build
          
      - name: Prepare Deployment Package
        run: |
          # Update index.html with the correct API URL (inject into script tag)
          API_URL="${{ env.REACT_APP_API_URL }}"
          echo "Updating API URL in index.html to: $API_URL"
          
          if [ -f ./frontend/build/index.html ]; then
            # Use Python to safely replace the URL (handles special characters better)
            python3 << EOF
import re
import sys

api_url = "$API_URL"
file_path = "./frontend/build/index.html"

try:
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Replace the API URL in the script tag
    # Pattern: window.REACT_APP_API_URL = window.REACT_APP_API_URL || 'old_url';
    pattern = r"window\.REACT_APP_API_URL = window\.REACT_APP_API_URL \|\| '[^']*';"
    replacement = f"window.REACT_APP_API_URL = window.REACT_APP_API_URL || '{api_url}';"
    
    new_content = re.sub(pattern, replacement, content)
    
    if new_content != content:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(new_content)
        print(f"‚úì Successfully updated index.html with API URL: {api_url}")
    else:
        # If pattern not found, try to add it before </head>
        if "REACT_APP_API_URL" not in content:
            script_tag = f"    <script>\n      window.REACT_APP_API_URL = window.REACT_APP_API_URL || '{api_url}';\n    </script>\n"
            new_content = content.replace("</head>", script_tag + "  </head>")
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            print(f"‚úì Added API URL script tag to index.html: {api_url}")
        else:
            print("‚ö†Ô∏è Pattern found but no replacement made. Current content:")
            import re
            match = re.search(r"REACT_APP_API_URL.*?;", content)
            if match:
                print(f"  Found: {match.group()}")
except Exception as e:
    print(f"Error updating index.html: {e}")
    sys.exit(1)
EOF
            
            # Verify the change
            if grep -q "$API_URL" ./frontend/build/index.html; then
              echo "‚úì Verified: API URL is in index.html"
            else
              echo "‚ö†Ô∏è Warning: Could not verify API URL update"
            fi
          else
            echo "‚ö†Ô∏è Warning: index.html not found in build directory"
          fi
          
          # Copy server.js and package.json to build directory
          cp ./frontend/server.js ./frontend/build/
          cp ./frontend/package.json ./frontend/build/
          
          # Create a minimal package.json for production (only express)
          cat > ./frontend/build/package.json << EOF
          {
            "name": "tsp-frontend",
            "version": "1.0.0",
            "main": "server.js",
            "scripts": {
              "start": "node server.js"
            },
            "dependencies": {
              "express": "^4.18.2"
            }
          }
          EOF
          
          echo "üì¶ Deployment package contents:"
          ls -la ./frontend/build/ | head -20
          echo ""
          echo "üìÑ Checking for required files:"
          ls -la ./frontend/build/index.html && echo "‚úì index.html found"
          ls -la ./frontend/build/server.js && echo "‚úì server.js found"
          ls -la ./frontend/build/package.json && echo "‚úì package.json found"
          
      - name: Configure Web App for Node.js
        run: |
          # Ensure Node.js version is set
          az webapp config appsettings set \
            --name ${{ secrets.WEBAPP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --settings WEBSITE_NODE_DEFAULT_VERSION="18-lts" SCM_DO_BUILD_DURING_DEPLOYMENT="true" || true
          
      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ secrets.WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: ./frontend/build